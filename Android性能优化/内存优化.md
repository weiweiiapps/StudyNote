# 内存优化

## 内存问题都有什么

    内存抖动 
        锯齿状,GC导致卡顿

    内存泄露 
        可用内存减少,频繁GC

    内存溢出
        OOM,程序异常

## 工具选择

### Memory Profiler(Android Profiler)

    实时图标方式展示应用内存使用量
    识别内存泄露,内存抖动
    提供捕获堆转储,强制GC以及跟踪内存分配的能力

### Bitmap 占内存分析

![image.png](https://upload-images.jianshu.io/upload_images/61189-8b293c9fb614c5ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/61189-8730dc3799c7f510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    在图中可看到堆中所有的Bitmap对象,列表上显示了Bitmap所占的内存大小,点击后可以查看对应是预览图

    Shallow size就是对象本身占用内存的大小，不包含其引用的对象。
    Retained size是该对象自己的shallow size，加上从该对象能直接或间接访问到对象的shallow size之和。换句话说，retained size是该对象被GC之后所能回收到内存的总和。

### 查看内存对象对应的源码

![image.png](https://upload-images.jianshu.io/upload_images/61189-77c6e99f26674efd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 按照包名来查看内存信息

![image.png](https://upload-images.jianshu.io/upload_images/61189-d50ef82ecc79a09a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### Memory Analyzer (MAT)

    强大的Java Heap分析工具,查找内存泄露,查看内存占用
    生成整体报告,分析问题
    配合 Android Profiler 深层次的定位内存泄露

    下载链接: https://www.eclipse.org/mat/downloads.php
    将 hprof -> conv 需要转换文件格式才能识别

### LeakCanary

    自动内存泄露检测

## Android 内存管理机制

    内存弹性分配,分配值与最大值受设备影响

## 内存抖动

### 什么是内存抖动

    内存频繁分配和回收导致内存不稳定
    表现为频繁GC,内存曲线呈锯齿状

### 内存抖动的危害

    内存抖动是因为频繁创建对象,会导致内存不足以及内存碎片(不连续),应用卡顿

### 如何检测内存抖动

    以下模拟个内存抖动来做排查

![image.png](https://upload-images.jianshu.io/upload_images/61189-f54148799a523cfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 用 Android Profiler 查看

    点击前

![image.png](https://upload-images.jianshu.io/upload_images/61189-c0e16009ff6b0e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    点击后模拟,并点击 record 记录内存分配情况

![image.png](https://upload-images.jianshu.io/upload_images/61189-726f4da01f065f97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/61189-c268d03d717b84ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    按照内存占用大小排序,点击查看可疑大对象的内存分配情况,以及具体方法位置,右键 jump to source 即可查看具体的位置
    找到位置之后,修复即可,主要难点还是在问题的定位上

### 内存抖动定位技巧

    循环或者频繁调用的地方

## 内存泄露

### 什么是内存泄漏

     简单来说对象由于编码错误或系统原因，仍然存在着对其直接或间接的引用，导致系统无法进行回收。
     内存泄露，容易留下逻辑隐患,同时增加了应用内存峰值与发生OOM的概率

## 如何规避内存泄露

    1. 使用静态内部类,不要是用非静态内部类/匿名内部类,
        因为他们会隐式的持有外部类的引用,这样外部类就可能会发生泄漏.如果要在静态内部类中使用外部类的属性或者方法时,可以配合弱引用使用

    2. 不要以为Java会永远帮你清理回收正在运行的threads,
        我们很容易误以为当Activity结束销毁时,会帮我们将正在运行的threads也结束回收掉,但并不是的,Java threads会一直存在,只有当线程运行完成或者被杀死的时候,线程才会被回收,所以我们应该养成手动结束线程的习惯,

    3. 尽量不自己开线程,
        Android设计了许多类来简化执行后台任务,可以开Service来执行后台任务,然后用BroadcastReceiver来向Activity返回结果,也可以用AsyncTask来执行简短的后台任务

    4. 频繁的使用static关键字修饰
        由于static声明变量的声明周期其实是和app的声明周期一样的(进程级别)大量使用会占据内存空间不释放,导致内存溢出

    5. Bitmap
        使用options 来进行条件允许的压缩,
        由于虚拟机不会主动回收Bitmap,所以在使用完毕之后需要自行调用recycle方法来进行回收,
        
    6. 引用地狱
        Activity生成的对象,原则上应该是在Activity生命周期结束会就释放掉的,Activity对象本身也是,尽量避免被 Application 级别的对象来引用,

    7. Cursor 关闭 查询数据库的时候,返回的Cursor,查询结束之后,及时关闭

    8. 读写的IO流 操作完毕之后 要及时关闭  

### 如何定位内存泄露

    使用Android Profiler 大致定位

![](https://upload-images.jianshu.io/upload_images/61189-ba83dcb96c4a5674.jpg)

    点击按钮来查看一段时间内Java堆的内存变化

![](https://upload-images.jianshu.io/upload_images/61189-edeec0568fd8e3fc.jpg)

    点击dump 堆信息 并保存成 hprof 文件

![image.png](https://upload-images.jianshu.io/upload_images/61189-d1b25c8f0f8436f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    使用命令 hprof-conv 将文件转换为可以查看的文件,并使用MAT打开文件

![image.png](https://upload-images.jianshu.io/upload_images/61189-5e629905d97d74f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/61189-597e55f3320db356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    点击查看 发现这个Activity 有4个实例 判断他这里发生了内存泄露

![image.png](https://upload-images.jianshu.io/upload_images/61189-c7a08f5f19fb7199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    点击可以查看有那些强引用引用着这个Activity

![image.png](https://upload-images.jianshu.io/upload_images/61189-2824b0043ee1143a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    点击查看 GC Root 查看所有的引用

![image.png](https://upload-images.jianshu.io/upload_images/61189-465279b5a165f84c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/61189-b5c80918449cd978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    也可以继承 LeakCanary 来初步检测内存泄露

## Bitmap优化

    使用AOP对Bitmap的宽高进行监控 来 动态检测Bitmap是否需要压缩

## ANR

### ANR 日志获取

``` java
adb shell kill -S QUIT PID 
adb pull /data/anr/traces.txt
```
traces.txt日志文件分析

一般traces.txt日志输出格式如下，本实例是在主线程中强行Sleep导致的ANR日志：

``` java
DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

"main" prio=5 tid=1 TIMED_WAIT
  | group="main" sCount=1 dsCount=0 obj=0xa4cc8bd8 self=0xb8b70eb0
  | sysTid=1635 nice=0 sched=0/0 cgrp=apps handle=-1217155008
  | state=S schedstat=( 41426029 22606846 158 ) utm=1 stm=2 core=2
  at java.lang.VMThread.sleep(Native Method)
  at java.lang.Thread.sleep(Thread.java:1013)
  at java.lang.Thread.sleep(Thread.java:995)
  at com.update.demo.MainActivity.startSleep(MainActivity.java:18)
  at com.update.demo.MainActivity.onCreate(MainActivity.java:11)
  at android.app.Activity.performCreate(Activity.java:5231)
  at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)
  at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2148)
  at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2233)
  at android.app.ActivityThread.access$800(ActivityThread.java:135)
  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1196)
  at android.os.Handler.dispatchMessage(Handler.java:102)
  at android.os.Looper.loop(Looper.java:136)
  at android.app.ActivityThread.main(ActivityThread.java:5001)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:515)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601)
  at dalvik.system.NativeStart.main(Native Method)

```

从上述内容可定位到是  MainActivity第18行的startSleep方法 如下图 修复即可

![](https://upload-images.jianshu.io/upload_images/61189-7b01cb37d0ad23c6.png)


## 优化细节

    MF文件中 LargeHeap 可以申请更多内存
        但是 LowMemoryKiller 会优先对其进行清理
        而且每个App都申请了,那系统还是会按照之前的大小来分配
    使用 Android 优化后的集合 SparseArray
    谨慎用 SharedPreference
