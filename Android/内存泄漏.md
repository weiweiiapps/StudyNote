# 内存泄漏

## 什么是内存泄漏

     简单来说对象由于编码错误或系统原因，仍然存在着对其直接或间接的引用，导致系统无法进行回收。
     内存泄露，容易留下逻辑隐患,同时增加了应用内存峰值与发生OOM的概率
     
## 如何规避

        1. 使用静态内部类,不要是用非静态内部类/匿名内部类,
            因为他们会隐式的持有外部类的引用,这样外部类就可能会发生泄漏.如果要在静态内部类中使用外部类的属性或者方法时,可以配合弱引用使用
        2. 不要以为Java会永远帮你清理回收正在运行的threads,
            我们很容易误以为当Activity结束销毁时,会帮我们将正在运行的threads也结束回收掉,但并不是的,Java threads会一直存在,只有当线程运行完成或者被杀死的时候,线程才会被回收,所以我们应该养成手动结束线程的习惯,
        3. 尽量不自己开线程,
            Android设计了许多类来简化执行后台任务,可以开Service来执行后台任务,然后用BroadcastReceiver来向Activity返回结果,也可以用AsyncTask来执行简短的后台任务
        4. 频繁的使用static关键字修饰
            由于static声明变量的声明周期其实是和app的声明周期一样的(进程级别)大量使用会占据内存空间不释放,导致内存溢出
        5. Bitmap
            由于虚拟机不会主动回收Bitmap,所以在使用完毕之后需要自行调用recycle方法来进行回收,
            使用options 来进行条件允许的压缩,
        6. 引用地狱
            Activity生成的对象,原则上应该是在Activity生命周期结束会就释放掉的,Activity对象本身也是,尽量避免被 Application 级别的对象来引用,
        7. Cursor 关闭 查询数据库的时候,返回的Cursor,查询结束之后,及时关闭
        8. 读写的IO流 操作完毕之后 要及时关闭  


## 如何检测

### 使用Android Profiler工具

[网址链接](https://blog.csdn.net/Double2hao/article/details/78784758)

![](https://upload-images.jianshu.io/upload_images/61189-ba83dcb96c4a5674.jpg)

    点击按钮来查看一段时间内Java堆的内存变化

![](https://upload-images.jianshu.io/upload_images/61189-edeec0568fd8e3fc.jpg)

### 使用LeakCanary

    若提供的 信息链不足以定位问题

### 性能检测工具




## ANR

### 日志获取

``` java
adb shell kill -S QUIT PID 
adb pull /data/anr/traces.txt
```
traces.txt日志文件分析

一般traces.txt日志输出格式如下，本实例是在主线程中强行Sleep导致的ANR日志：

``` java
DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

"main" prio=5 tid=1 TIMED_WAIT
  | group="main" sCount=1 dsCount=0 obj=0xa4cc8bd8 self=0xb8b70eb0
  | sysTid=1635 nice=0 sched=0/0 cgrp=apps handle=-1217155008
  | state=S schedstat=( 41426029 22606846 158 ) utm=1 stm=2 core=2
  at java.lang.VMThread.sleep(Native Method)
  at java.lang.Thread.sleep(Thread.java:1013)
  at java.lang.Thread.sleep(Thread.java:995)
  at com.update.demo.MainActivity.startSleep(MainActivity.java:18)
  at com.update.demo.MainActivity.onCreate(MainActivity.java:11)
  at android.app.Activity.performCreate(Activity.java:5231)
  at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)
  at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2148)
  at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2233)
  at android.app.ActivityThread.access$800(ActivityThread.java:135)
  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1196)
  at android.os.Handler.dispatchMessage(Handler.java:102)
  at android.os.Looper.loop(Looper.java:136)
  at android.app.ActivityThread.main(ActivityThread.java:5001)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:515)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601)
  at dalvik.system.NativeStart.main(Native Method)

```

从上述内容可定位到是  MainActivity第18行的startSleep方法 如下图 修复即可

![](https://upload-images.jianshu.io/upload_images/61189-7b01cb37d0ad23c6.png)
