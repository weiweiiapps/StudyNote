
# 垃圾回收(GC)

## 四种引用

    强引用: 只要存在强引用,GC就永远不会回收掉被引用的对象(即使发生OOM)
    弱引用: 内存不足才会回收
    软引用: GC扫描到,不管内存是否足够都会将其回收
    虚引用: 同软引用
    
## 内存分配
    内存大致分为 新生代 和 老年代

    新生代包含 Eden区 和 s0 s1区
        对象首先在 Eden区创建
        经历过一次GC后,会分配到 s0 s1区,
        若对象过大也会直接存放至 老年代

    老年代 相当于永久区 存放经历多次GC,存活率高的对象(即长期存活的对象)

## 如何判断对象是否为垃圾

    引用计数法
        给对象中添加一个引用计数器,每当有一个地方引用它时,计数器就+1,当引用失效时,计数器就-1,任何时刻计数器为0的对象就是不可能再被使用的,

    可达性分析算法
        以可以成为GC Roots的对象为起点,向下搜索,搜索走过的路径称为引用链,当一个对象到GC Roots没有引用链相连(即这个点到roots 不可达),则证明这个对象是不可用的
        
    能作为GC Roots的对象包括
        1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
        2. 方法区中类静态属性引用的对象
        3. 方法区中常量引用的对象
        4. 本地方法栈中 Native 方法引用的对象

## 何时回收垃圾对象

    当Eden区没有足够空间进行分配给对象时,虚拟机就会发起一次GC

## 如何回收垃圾对象

    标记清除算法
        首先标记出所有需要回收的对象,在标记完成后统一回收被标记的对象
        效率不高

    复制算法 (新生代使用 s0区 s1区)
        将可用内存安容量划分为大小相等的两块,每次只使用其中的一块,当这一块的内存用完了,就将还存活的对象赋值到另外一块内存上面,然后再把已使用过的内存空间一次清理掉

    标记整理算法 (老年代使用)
        首先标记出所有需要回收的对象,在标记完成后讲所有存活的对象向同一端移动,然后直接清理掉端边界意外的内存

[白话 JVM——深入对象引用](https://juejin.im/entry/57a4aaee0a2b580058468c29)